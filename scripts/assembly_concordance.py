import argparse
from collections import Counter
from cyvcf2 import VCF, Writer
import pysam
import sys
import os
import subprocess
from pybedtools import BedTool
from aam_mod import cooper


tool_choices = ["strkit", "strdust", "longTR", "atarva", "medaka", "strkitrr"] # no support for vamos for now


def parse_args():
    parser = argparse.ArgumentParser(description="Compare assembly-based genotypes with variant calls in the tool.")
    parser.add_argument("-v", "--vcf", required=True, type=str, help="VCF file generated by a TR genotyper tool.")
    parser.add_argument("-a", "--aln", required=True, nargs=2, type=str, metavar=('MAT_ALN','PAT_ALN'),
                        help="Two BAM files (e.g. assemblies) of maternal and paternal assemblies alignment with reference.")
    parser.add_argument("-t", "--tool", required=True, type=str, choices=tool_choices, default="atarva", help="TR genotyping tool used.")

    optional_args = parser.add_argument_group("Optional Arguments")
    optional_args.add_argument("-o", "--output", type=argparse.FileType("w"), default=sys.stdout, help="Output file to write concordance results. Default: concordance_results.txt")
    optional_args.add_argument("-bed", "--regions", type=str, default=None, help="BED file containing TR regions to analyze.")
    optional_args.add_argument("--catalogue-coords", action="store_true", default=False, help="Whether to check the concordance strictly within the coordinates given in the catalogue.")

    args = parser.parse_args()

    if args.catalogue_coords and args.regions == None:
        parser.error("--catalogue-coords requires --regions to be specified.")
    return args


def get_assembly_genotypes(mat_aln, pat_aln, _bgz_bed):
    """
    Get the locus genotypes from maternal and paternal assemblies.

    :param mat_aln: pysam.AlignmentFile object for maternal assembly
    :param pat_aln: pysam.AlignmentFile object for paternal assembly
    :param _bgz_bed: bgzipped and tabix-indexed BED file containing TR regions
    :return: Dictionary with locus as key and genotype (list of two allele lengths) as value
    """

    mat_alleles = cooper(mat_aln, _bgz_bed, 5, 0)
    pat_alleles = cooper(pat_aln, _bgz_bed, 5, 0)

    assembly_genotypes = {}
    for locus in mat_alleles.keys():
        if locus not in pat_alleles: continue
        mat_allele = mat_alleles[locus][1]
        pat_allele = pat_alleles[locus][1]
        assembly_genotypes[locus] = [mat_allele, pat_allele] if mat_allele <= pat_allele else [pat_allele, mat_allele]

    return assembly_genotypes


def get_locus_key(var, tool):
    """
    Get a unique locus key based on the tool used.

    :param var: cyvcf2.Variant object
    :param tool: Tool name as string
    :return: Locus key as string
    """
    if tool == "longTR": return 'chr' + '-'.join(var.ID.split('-')[:3])
    if tool == "strkit": return f"{var.CHROM}-{var.INFO['BED_START']}-{var.INFO['BED_END']}"
    if tool == "atarva": return f"{var.CHROM}-{var.start+1}-{var.INFO['END']}"
    if tool == "strdust": return f"{var.CHROM}-{var.start+1}-{var.INFO['END']}"
    return None


def process_vcf(vcf, tool):
    """
    Process the VCF file to extract variant information and genotypes.

    :param vcf: Path to VCF file
    :param tool: Tool name as string
    :return: Tuple of (list of BED entries, dictionary of tool genotypes)
    """
    tool_genotypes = {}
    bed_entries = []
    locus_keymap = {}
    for v in VCF(vcf): # or VCF('some.bcf')
        ref = v.REF
        alt = v.ALT

        chrom = v.CHROM
        start = v.start
        if tool == 'atarva' or tool == 'strdust': start += 1  # atarva creates a 0-based VCF file
        end = start + len(ref)      # v.end is also available but is taken from END INFO field

        bed_entries.append((chrom, start, end))
        locus_key = get_locus_key(v, tool)

        haploid = False
        # come back to solve it for haploid chromosomes
        if chrom == 'chrX' or chrom == 'chrY': continue

        if not v.genotypes: continue
        allele_set = [len(ref)] + [len(a) for a in alt] # set of allele lengths including reference

        tool_genotype = []
        # v.genotypes is a list of lists, with genotype of each sample
        # for one sample [allele1, allele2, phased?]
        for gt in v.genotypes[0][:2]:
            try: tool_genotype.append(allele_set[int(gt)])
            except ValueError: tool_genotype.append(False)
        tool_genotype.sort() 
        tool_genotypes[locus_key] = tool_genotype
        locus_keymap[locus_key] = f'{chrom}-{start}-{end}'

    return bed_entries, tool_genotypes, locus_keymap


def sort_bed_pybedtools(input_bed, output_bed):
    """
    Sort a BED file using pybedtools and write to a new file.
    Sorting uses BEDTools' default: chrom -> start -> end.
    :param input_bed: Path to input BED file
    :param output_bed: Path to output sorted BED file
    :return: None
    """
    bed = BedTool(input_bed)
    sorted_bed = bed.sort()
    sorted_bed.saveas(output_bed)


def length_difference(tool_genotype, assembly_genotype):
    """
    Calculate the length difference between tool genotype and assembly genotype.

    :param tool_genotype: List of two allele lengths from the tool
    :param assembly_genotype: List of two allele lengths from the assembly
    :return: Tuple of length differences for both alleles
    """

    if not tool_genotype or not assembly_genotype or len(tool_genotype) != 2 or len(assembly_genotype) != 2:
        return (None, None)
    # handle missing alleles encoded as False/None
    if any(x is False or x is None for x in tool_genotype + assembly_genotype):
        return (None, None)

    a0, a1 = tool_genotype
    b0, b1 = assembly_genotype

    # two possible pairings; choose the one with smaller total difference
    d_pair1 = [abs(a0 - b0), abs(a1 - b1)]
    d_pair2 = [abs(a0 - b1), abs(a1 - b0)]

    if (d_pair1[0] + d_pair1[1]) <= (d_pair2[0] + d_pair2[1]):
        return d_pair1, [a0, b0], [a1, b1]
    else:
        return d_pair2, [a0, b1], [a1, b0]


def main():
    args = parse_args()
    vcf = args.vcf
    aln = args.aln
    tool = args.tool
    output = args.output

    locus_motif = {}
    with open(args.regions) as fh:
        for line in fh:
            line = line.strip().split('\t')
            line[1] = int(line[1])
            line[2] = int(line[2])
            key = f"{line[0]}-{line[1]}-{line[2]}"
            if tool == "longTR": key = f"{line[0]}-{int(line[1])-1}-{line[2]}"
            locus_motif[key] = line[3]

    mat_aln = pysam.AlignmentFile(aln[0], "rb")
    pat_aln = pysam.AlignmentFile(aln[1], "rb")

    locus_keymap = {}
    bed_entries, tool_genotypes, locus_keymap = process_vcf(vcf, tool)

    # creates a temporary bed file of the regions from the VCF file
    tmp_tbx = open('temp.bed', 'w')
    for bed in bed_entries:
        tmp_tbx.write(f"{bed[0]}\t{bed[1]}\t{bed[2]}\n")
    tmp_tbx.close()
    sort_bed_pybedtools("temp.bed", "temp.sorted.bed")

    _bgz_bed = "temp.bed.gz"
    pysam.tabix_compress("temp.sorted.bed", _bgz_bed, force=True)
    pysam.tabix_index(_bgz_bed, preset="bed", force=True)
    tbx = pysam.TabixFile(_bgz_bed)

    # optional: remove intermediate/uncompressed files
    os.remove("temp.sorted.bed")
    os.remove("temp.bed")

    assembly_genotypes = get_assembly_genotypes(mat_aln, pat_aln, tbx)

    print("#catalog_locus\tmotif\tvcf_locus\tcoord_change\tlength_difference\ttool_genotype\tassembly_genotype\ttool\tstatus", file=output)
    total_regions = 0
    missed_regions = 0
    oneoff_regions = 0
    called_regions = 0
    match_regions = 0
    catalogue_regions = 0
    for locus in tool_genotypes.keys():
        coord_change = 'CHANGED'
        vcf_key = locus_keymap[locus]
        if vcf_key == f'{locus.split("-")[0]}-{int(locus.split("-")[1])+1}-{locus.split("-")[2]}':
            coord_change = 'UNCHANGED'
        motif = locus_motif[locus]

        if vcf_key not in assembly_genotypes:
            print(f"{locus}\t{motif}\t{vcf_key}\t{coord_change}\tNA\tNA\tNA\t{tool}\tMISSING", file=output)
            missed_regions += 1
        else:
            called_regions += 1
            ldiff, pair1, pair2 = length_difference(tool_genotypes[locus], assembly_genotypes[vcf_key])
            tag = ""
            if sum(ldiff) == 0:
                match_regions += 1
                tag = "MATCH"
            elif max(ldiff) == 1:
                oneoff_regions += 1
                tag = "ONE-OFF"
                match_regions += 1  # consider one-off as match for concordance calculation
            else:
                tag = "MISMATCH"
            output.write(f"{locus}\t{motif}\t{vcf_key}\t{coord_change}\t{pair1[0]-pair1[1]},{pair2[0]-pair2[1]}\t{pair1[0]},{pair2[0]}\t{pair1[1]},{pair2[1]}\t{tool}\t{tag}\n")
        total_regions += 1
    print(f"#Total regions in VCF: {total_regions}", file=output)
    print(f"#Regions missed (no assembly genotype): {missed_regions}", file=output)
    print(f"#Regions called (with assembly genotype): {called_regions}", file=output)
    print(f"#Matching genotypes: {match_regions}", file=output)
    print(f"#One-off genotypes: {oneoff_regions}", file=output)
    if called_regions > 0:
        concordance = match_regions / called_regions * 100
    else:
        concordance = 0.0
    print(f"#Concordance: {concordance:.2f} %", file=output)
    os.remove("temp.bed.gz")
    os.remove("temp.bed.gz.tbi")
    mat_aln.close()
    pat_aln.close()
    output.close()

if __name__ == "__main__":
    main()